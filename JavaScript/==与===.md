
[== 相等](https://262.ecma-international.org/5.1/#sec-11.9.3)

```js
  // 起因：
  ++[[]][+[]]+[+[]] == 10
```

```js
1. {} + {} //chrome:"[object Object][object Object]"，Firfox:NaN
2. {} + [] // 0 ??
3. [] + {} //"[object Object]"
4. {} + 1 // 1 ??
5. ({} + 1) // "[object Object]1"
6. 1 + {} // "1[object Object]"
7. [] + 1 // 1
8. 1 + [] // 1
9. 1 - [] // 1
10. 1 - {} // NaN
11. 1 - !{} // 1
12. 1 + !{} // 1
13. 1 + "2" + "2" // 122
14. 1+ + "2" + "2" // 32
15. 1++"2"+"2" // 报错
16. []==![] // true
17. []===![] // false
```

#### 一元 `+` 和 一元 `-` 操作符

[规范](https://262.ecma-international.org/5.1/#sec-11.4.6)

> + UnaryExpression: +UnaryExpression

一元 + 运算符将其操作数转换为 `Number` 类型。

1. Let expr be the result of evaluating UnaryExpression.
2. Return `ToNumber(GetValue(expr))`.

```js
var sNum = "20";
alert(typeof sNum); //输出 "string"
var iNum = +sNum;
alert(typeof iNum); //输出 "number"

// Number({}) => NaN
+{} // NaN
+[] // 0
+function() {} // NaN
```

> - UnaryExpression: -UnaryExpression

一元 - 运算符将其操作数转换为 `Number` 类型，然后将其取反。 请注意， `+0` 取反会产生 `-0`，`-0` 取反会产生`+0`。

1. Let expr be the result of evaluating UnaryExpression.
2. Let `oldValue` be `ToNumber(GetValue(expr))`.
3. If `oldValue` is `NaN`, return `NaN`.
4. Return the result of negating `oldValue`; that is, compute a Number with the same magnitude but opposite sign.

```js
var sNum = "20";
alert(typeof sNum); //输出 "string"
var iNum = -sNum;
alert(iNum);        //输出 "-20"
alert(typeof iNum); //输出 "number"

-{} // NaN
-[] // -0
```

#### 加法运算符（+）

[+运算符规范](https://262.ecma-international.org/5.1/#sec-11.6.1)

加法运算符执行字符串连接或数字加法。

**在处理特殊值时，ECMAScript 中的加法也有一些特殊行为：**

- 某个运算数是 `NaN`，那么结果为 `NaN`。
- `-Infinity` 加 `-Infinity`，结果为 `-Infinity`。
- `Infinity` 加 `-Infinity`，结果为 `NaN`。
- `+0` 加 `+0`，结果为 `+0`。
- `-0` 加 `+0`，结果为 `+0`。
- `-0` 加 `-0`，结果为 `-0`。

不过，如果某个运算数是字符串，那么采用下列规则：

- 如果两个运算数都是字符串，把第二个字符串连接到第一个上。
- 如果只有一个运算数是字符串，把另一个运算数转换成字符串，结果是两个字符串连接成的字符串。

```js
1 + '1' // 11 (string)
```

#### 减法运算符（-）

[-运算符规范](https://262.ecma-international.org/5.1/#sec-11.6.2)

**处理特殊值时，减法运算符也有一些特殊行为:**

- 某个运算数是 NaN，那么结果为 NaN。
- `Infinity` 减 `Infinity`，结果为 `NaN`。
- `-Infinity` 减 `-Infinity`，结果为 `NaN`。
- `Infinity` 减 `-Infinity`，结果为 `Infinity`。
- `-Infinity` 减 `Infinity`，结果为 `-Infinity`。
- `+0` 减 `+0`，结果为 `+0`。
- `-0` 减 `-0`，结果为 `-0`。
- `+0` 减 `-0`，结果为 `+0`。
- 某个运算符不是数字，那么结果为 NaN。


#### ToNumber(x)

[规范定义](https://262.ecma-international.org/5.1/#sec-9.3)

![image](https://user-images.githubusercontent.com/25894364/125579402-6dfcfd84-1234-4a6b-b676-564b49acc0d5.png)

> String 转成 Number比较复杂 `(parseInt())`

#### ToPrimitive(x)

[规范定义](https://262.ecma-international.org/5.1/#sec-9.1)

> 原始值(primitives) 

1. undefined
2. null
3. boolean
4. number
5. string

![image](https://user-images.githubusercontent.com/25894364/125580025-e5c47c7b-8bd1-4ffc-9366-2501f74ba2e3.png)


#### `[[DefaultValue]] (hint)`

[DefaultValue - 规范定义](https://262.ecma-international.org/5.1/#sec-8.12.8)

> `ToPrimitive(goal, preferredType)`

JS引擎内部转换为原始值`ToPrimitive(goal, preferredType)`函数接受两个参数，第一个`goal`为被转换的对象，第二个`preferredType`为希望转换成的类型（默认为空，接受的值为`Number`或`String`）

在执行`ToPrimitive(goal,preferredType)`时如果第二个参数为空并且`goal`为`Date`的事例时，此时`preferredType`会被设置为`String`，其他情况下`preferredType`都会被设置为`Number`

如果`preferredType`为`Number`，`ToPrimitive`执行过程如下：

1. 如果goal为原始值，直接返回；
2. 否则调用 goal.valueOf()，如果执行结果是原始值，返回之；
3. 否则调用 goal.toString()，如果执行结果是原始值，返回之；
4. 否则抛异常。

如果`preferredType`为`String`，将上面的第2步和第3步调换，即：
1. 如果goal为原始值，直接返回；
2. 否则调用 goal.toString()，如果执行结果是原始值，返回之；
3. 否则调用 goal.valueOf()，如果执行结果是原始值，返回之；
4. 否则抛异常。


> goal.toString 与 goal.valueOf

`toString`用来返回对象的字符串表示。
`valueOf`方法返回对象的原始值，可能是字符串、数值或bool值等，看具体的对象。

```js
const a = { name: 'ahah' };
a.toString(); // '[object Object]'
a.valueOf(); // { name: 'ahah' }

const b = [1, 2, 4];
b.toString(); // "1,2,4"
b.valueOf(); // [1,2,4]

const date = new Date();
date.toString(); // Sun Feb 28 2016 13:40:36 GMT+0800 (中国标准时间)
date.valueOf(); // 1456638436303

```

```js
const toPrimitive = (goal, preferredType='Number') => {
  let Utils = {
    typeOf: function(goal) {
      return Object.prototype.toString.call(goal).slice(8, -1);
    },
    isPrimitive: function(goal) {
      let types = ['Null', 'String', 'Boolean', 'Undefined', 'Number'];
      return types.indexOf(this.typeOf(goal)) !== -1;
    }
  };

  if (Utils.isPrimitive(goal)) {
    return goal;
  }

  preferredType = (preferredType === 'String' || Utils.typeOf(goal) === 'Date') ?
    'String' : 'Number';

  if (preferredType === 'Number') {
    if (Utils.isPrimitive(goal.valueOf())) {
      return goal.valueOf()
    };
    if (Utils.isPrimitive(goal.toString())) {
      return goal.toString()
    };
  } else {
    if (Utils.isPrimitive(goal.toString())) {
      return goal.toString()
    };
    if (Utils.isPrimitive(goal.valueOf())) {
      return goal.valueOf()
    };
  }
}

const a = {};
ToPrimitive(a);//"[object Object]",与上面文字分析的一致
```


#### 解析`++[[]][+[]]+[+[]]`

[运算符的优先级](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)


```js
// 运算符的优先级： ++ 优先级高于 + 

// 拆分 ++ 自增运算法
(++[[]][+[]]) + ([+[]])

// [+[]] 解析

+[] // 一元+运算符 []会取ToNumber的值 [].valueOf() => [] => [].toString() => ''  => +'' => +0

[+[]] => [0]

// ++[[]][+[]] 解析

++[[]][+[]] => ++[[]][0]


// 运算符的优选级 属性访问器（数组取下标）优先级高于 ++

[[]][0] => []

++[[]][0] => ++[]

// 变形式：

++[[]][+[]]+[+[]] => ++[] + [0]
```

> 问题：

`++[[]][0]`在浏览器不报错`++[]`在浏览器报错了.

`++[]`: `Uncaught SyntaxError: Invalid left-hand side expression in prefix operation `

[前缀自增运算符规范](https://262.ecma-international.org/5.1/#sec-11.4.4)

> `a++`先赋值，后自增
> `++a`先自增，后赋值

关键`Call PutValue(expr, newValue).`

`[[]][0]`是对象的属性访问，而我们知道对象的属性访问返回的是引用，所以可以正确执行。

`++[]` => [] + 1 => 1 (Number)

`++[[]][+[]]+[+[]]` => 1 + [0];

[0].valueOf() => [0] => [0].toString() => '0'

`++[[]][+[]]+[+[]]` => 1 + '0' => '10'

#### 抽象相等的比较算法
